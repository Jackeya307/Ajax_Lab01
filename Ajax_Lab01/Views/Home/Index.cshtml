@model IEnumerable<Address>
@section Style {

}

<fieldset class="row row-cols-1">
    <legend>地址選擇</legend>
    <form class="form form-control">
        <select class="" onchange="btnClick(event)">
            <option value="1" selected>請選擇..</option>
            @foreach(var item in Model.Select(Address => Address.City).Distinct()) {
                <option value="@Html.Raw(item)">@Html.Raw(item)</option>
            }
        </select>
        <select class="" onchange="siteChange(event)" id="siteid">
            <option selected>請先選擇城市</option>
        </select>
        <select class="" id="road" onchange="textAddress(event)">
            <option selected>請先選擇鄉鎮區</option>
        </select>
        <input placeholder="選擇路段後輸入詳細地址"
               class="text form-control-plaintext border border-primary" name="address" id="address" />
        <button type="submit">提交</button>
    </form>
</fieldset>
@section Scripts {
    <script>
        const siteid = document.querySelector('#siteid')
        const address = document.querySelector('#address')

        //重新選擇城市的時候必須全空
        async function btnClick(event) {

            address.value = ''  //每次CITY變動都清空INPUT
            siteid.innerHTML = '<option value="1" selected>請選擇...</option>' //鄉鎮區回預設
            road.innerHTML = '<option value="1" selected>請先選擇鄉鎮區</option>' //路也一樣

            if (event.target.value === '1')  //如果city選預設值就不傳送要求
                return

            const api = `@Url.Content("~/home/siteid/")${event.target.value}`
            await addressInfo(api, siteid);

            // for (let i = 0; i < data.length; i++) {
            //     siteid.insertAdjacentHTML('beforeend',
            // `<option value="${data[i]}">${data[i]}</option>`)
            // }
        }

        const road = document.querySelector('#road')

        //重新選擇鄉鎮區時需等於城市加新鄉鎮區
        async function siteChange(event) {

            road.innerHTML = '<option value="1" selected>請選擇鄉鎮區</option>' //換了區就把路調回預設
            address.value = ''

            if (event.target.value === '1') //區選預設就不傳要求
                return

            const api = `@Url.Content("~/home/Road/")${event.target.value}`
            addressInfo(api, road)

            // const response = await fetch(api)
            // const data = await response.json()
            // data.forEach(item =>
            //     road.insertAdjacentHTML('beforeend', `<option value="${item}">${item}</option>`))
        }

        //將地址自動填入input
        async function textAddress() {
            if (event.target.value === '1')  //路是預設就不填入地址
                return

            const allValue = Array.from(document.querySelectorAll('form>select'))
                .map((select) => select.value)//將全部下拉選單的值填入input
            address.value = allValue.join('')
        }

        async function addressInfo(api, site) {
            try {

                const response = await fetch(api);
                if (!response.ok) {
                    console.error('Api請求失敗: ', response.statusText)
                    return;
                }
                const data = await response.json();
                data.forEach(item =>
                    site.insertAdjacentHTML('beforeend', 
                    `<option value="${item}">${item}</option>`
                ));
            } catch(error) {
                console.error('處理API時發生錯誤: ',error)
            }
        }
        // const aborter = new AbortController()
        // const dad = aborter.signal
        // function btnClick(Event) {
        //     fetch(`/Home/Siteid/${Event.target.innerHTML}`, { signal: dad }) // 發送 HTTP GET 請求
        //         .then(response => response.text())
        //         .then(data => {
        //             context1.innerHTML = data
        //             Event.target.setAttribute('disabled', 'disabled')
        //         })
        //         .catch(error => {
        //             alert('錯誤發生: ' + error);
        //         });
        // }
        // aborter.abort()

    </script>
    <script>
        // setTimeout(() => {
        //     console.log('a');
        //     setTimeout(() => {
        //         console.log('b')
        //         setTimeout(() => console.log('c'), 1000)
        //     }, 2000)
        // }, 3000)

        // setTimeout(() => console.log('a'), 3000)
        // setTimeout(() => console.log('b'), 2000)
        // setTimeout(() => console.log('c'), 1000)
        // function doSomething(callback) {
        //     setTimeout(() => {
        //         console.log('Done');
        //         callback();
        //     }, 1000);
        // }

        // doSomething(() => {
        //     console.log('Next step');
        // });
        // (async () => {
        //     const Api = `@Url.Content("~/Home/Siteid")`
        //     const response = await fetch(Api)
        //     response.headers.forEach((value, name, array) => {
        //         console.log(`${name}: ${value}`)
        //         console.log(array)
        //     })
        // })()
    </script>
    <script>
        // async function cookingAndWashing() { //請不要閒下來
        //     return new Promise(washing => setTimeout(() => { //Promise初始化可以放兩個參數 預設要執行跟例外狀況執行的方法
        //         console.log('吐司考完了'); // 先烤土司 假設吐司要烤五分鐘
        //         washing() // 吐司開始烤就先去刷牙洗臉
        //     }, 5000)) //吐司要烤五分鐘
        // }



        // async function morning() {
        //     console.log('開始烤吐司')
        //     const wash = cookingAndWashing()
        //     console.log('開始刷牙')
        //     await wash //因為非同步等待 所以這裡會開始刷牙 吐司烤好 牙也就刷好了
        //     console.log('刷完牙了');
        // }

        // morning(); //早上起床準備事項
    </script>
}